/*
 * modZig_controller.c
 *
 *  Created on: 20 дек. 2013 г.
 *      Author: 17095
 */
#include "contiki.h"
#include "error.h"
#include "hal/micro/cortexm3/flash.h"

#include "mmem.h"

#include "dev/leds.h"
#include "modzig.h"
#include <stdio.h>
#include <string.h>

#include "dev/uart1.h"
#include <slip/slip.h>
#include "flash_proto.h"
#include "mzConfig.h"
#define UTIL_SPEED 115200
#define CRCBYTES 2
//we can't hold more than flash avaible
#define MAXBUF (MZ_CONFIGSIZE + CRCBYTES+ 2) //2 bytes for command word


static struct mmem	membuf;static unsigned char *lbuf;
static unsigned int rsize = 0;
static unsigned int dsize;

static unsigned int rx = 0, tx = 0;

/*---------------------------------------------------------------------------*/
PROCESS(utility_process, "Utility mode thread");
//AUTOSTART_PROCESSES(&mesh_controller_process);
/*---------------------------------------------------------------------------*/
#define send_char(x)  {tx++; uart1_writeb(x);}

/* CRC16 implementation acording to CCITT standards */

static const unsigned short crc16tab[256] = { 0x0000, 0x1021, 0x2042, 0x3063,
		0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c,
		0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294,
		0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff,
		0xe3de, 0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
		0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 0x3653,
		0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0xb75b, 0xa77a,
		0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 0x48c4, 0x58e5, 0x6886,
		0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 0xc9cc, 0xd9ed, 0xe98e, 0xf9af,
		0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71,
		0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58,
		0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60,
		0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
		0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0xff9f,
		0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 0x9188, 0x81a9,
		0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 0x1080, 0x00a1, 0x30c2,
		0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0xa3fb, 0xb3da,
		0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235,
		0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f,
		0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424,
		0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
		0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0xd94c,
		0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 0x5844, 0x4865,
		0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 0xcb7d, 0xdb5c, 0xeb3f,
		0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16,
		0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa,
		0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83,
		0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9,
		0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0 };

unsigned short crc16_ccitt(const unsigned char *mem, int len) {
	int counter;
	unsigned short crc = 0;
	for (counter = 0; counter < len; counter++) {
		crc = (crc << 8) ^ crc16tab[((crc >> 8) ^ *(char *) mem++) & 0x00FF];
	}

	return crc;
}

static char staffCk = 0;
//static void utility_got_packet();

static int utility_input_byte(unsigned char c) {
	rx++;
	if (!staffCk) {

		/* handle bytestuffing if necessary
		 */
		switch (c) {

		/* if it's an END character then we're done with
		 * the packet
		 */
		case END:
			/* a minor optimization: if there is no
			 * data in the packet, ignore it. This is
			 * meant to avoid bothering IP with all
			 * the empty packets generated by the
			 * duplicate END characters which are in
			 * turn sent to try to detect line noise.
			 */
			if (rsize) {
				process_poll(&utility_process);
				//rsize = 0;
			}
			break;

			/* if it's the same code as an ESC character, wait
			 * and get another character and then figure out
			 * what to store in the packet based on that.
			 */
		case ESC:
			staffCk = 1;
			break;
			/* here we fall into the default handler and let
			 * it store the character for us
			 */
		default:
			if (rsize < MAXBUF) {
				lbuf[rsize] = c;
				rsize++;
			}
		}

	} else {
		/* if "c" is not one of these two, then we
		 * have a protocol violation.  The best bet
		 * seems to be to leave the byte alone and
		 * just stuff it into the packet
		 */
		switch (c) {
		case ESC_END:
			c = END;
			if (rsize < MAXBUF) {
				lbuf[rsize] = c;
				rsize++;
			}
			break;
		case ESC_ESC:
			c = ESC;
			if (rsize < MAXBUF) {
				lbuf[rsize] = c;
				rsize++;
			}
			break;
		default:
			rsize = 0; //Truly invalid packet - resetting
		}
		staffCk = 0;
	}

	return 0;
}

/*
 static void utility_got_packet() {
 process_poll();
 }
 */
void send_packet(unsigned char *p, int len) {

	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	send_char(END);

	/* for each byte in the packet, send the appropriate character
	 * sequence
	 */
	while (len--) {
		switch (*p) {
		/* if it's the same code as an END character, we send a
		 * special two character code so as not to make the
		 * receiver think we sent an END
		 */
		case END:
			send_char(ESC)
			;
			send_char(ESC_END)
			;
			break;

			/* if it's the same code as an ESC character,
			 * we send a special two character code so as not
			 * to make the receiver think we sent an ESC
			 */
		case ESC:
			send_char(ESC)
			;
			send_char(ESC_ESC)
			;
			break;
			/* otherwise, we just send the character
			 */
		default:
			send_char(*p)
			;
		}

		p++;
	}

	/* tell the receiver that we're done sending the packet
	 */
	send_char(END);
}

void utility_mode_init() {

	if (mmem_alloc( &membuf, MAXBUF)){

		lbuf =  (unsigned char *)MMEM_PTR(&membuf);

	uart1_init(UTIL_SPEED);
	uart1_set_input(utility_input_byte);

	leds_on(LEDS_CONF_BLUE | LEDS_CONF_RED | LEDS_CONF_GREEN);//mode indication

	process_start(&utility_process, NULL);


	}else{
		//suddenly not enough memory O_o
		halErrorHalt();
	}
}
/*---------------------------------------------------------------------------*/
//PROCESS_THREAD(mesh_controller_process, ev, data)
//  PROCESS_EXITHANDLER(mesh_close(&mesh);)
//  PROCESS_BEGIN();
PROCESS_THREAD(utility_process, ev, data) {
//	PROCESS_EXITHANDLER(mesh_close(&mesh);)
	PROCESS_BEGIN()
		;

		while (1) {

			PROCESS_YIELD_UNTIL(ev == PROCESS_EVENT_POLL);

			//verifying crc first
			unsigned short crcA, crcB;

			crcB = (unsigned short) ((lbuf[rsize - CRCBYTES])
					| (unsigned short) (lbuf[rsize - CRCBYTES + 1]) << 8);

			crcA = crc16_ccitt(lbuf, rsize - CRCBYTES);
			//crcB = (lbuf[rsize-CRCBYTES]);
			//crcB = crcB << 8;
			if (crcA == crcB) {

				proto_frame_t *pkt = (proto_frame_t *) lbuf;
				pf_cmd_e cmd = pkt->cmd;
				dsize = 4;			//minimal response size
				switch (cmd) {

				case CMD_PING:
					pkt->cmd = RPL_PONG;
					break;

				case CMD_READ_CNF:
					pkt->cmd = RPL_DATA_CNF;
					memcpy(pkt->data, (int8u*) mzCONFIG, MZ_CONFIGSIZE);
					dsize += MZ_CONFIGSIZE;
					break;

				case CMD_WRITE_CNF: {
					int ret = 0;
					//simply writing to flash
					int size = (rsize - 3) / 2;
					ret = conf_save((char*)pkt->data,size);
					pkt->cmd = RPL_DATA_STS;
					pkt->data[0] = ret;
					dsize += 1;			//space for responce code
					break;
				}

				case CMD_GET_MAC:
					pkt->cmd = RPL_MAC;
					//int8u *add = ST_RadioGetEui64();
					memcpy(pkt->data, (int8u*)  &rimeaddr_node_addr, sizeof(rimeaddr_t));
					dsize += sizeof(rimeaddr_t);
					break;


				default: //Filtering erroneous commands
					pkt->cmd = RPL_UNKNOWN_CMD;
					break;
				}

				//checksumming
				crcA = crc16_ccitt(lbuf, dsize - CRCBYTES);
				(lbuf[dsize - CRCBYTES]) = (char) (crcA >> 8);
				(lbuf[dsize - CRCBYTES + 1]) = (char) (crcA);

				//reply send
				send_packet(lbuf, dsize);
			}
			//freeing packet buffer
			rsize = 0;
		}

	PROCESS_END();
}
/*---------------------------------------------------------------------------*/

